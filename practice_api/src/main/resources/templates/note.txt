cookie：
1.以键值对的形式存储信息在浏览器
2.cookie不能跨域，当前及其父级域名可以取值
3.cookie可以设置有效期
4.cookie可以设置path

session
1.基于服务器内存的缓存(非持久化), 可保存请求会话
2.每个session通过sessionid来区分不同请求
3.session可设置过期时间
4.session也是以键值对形式存在的

购物车存储形式 - Cookie
1.无需登录、无需查库、保存在浏览器端
2.优点：性能好、访问快、没有数据库交互
3.缺点：换电脑数据丢失、电脑他人登录使用涉及隐私安全
购物车存储形式 - Session
1.用户登录后，购物车数据放入用户会话
2.优点：初期性能较好，访问快
3.缺点：session基于内存，用户量庞大影响用户性能；只能存在于当前会话，不适用集群与分布式系统
购物车存储形式 - 数据库
1.用户登录后，购物车数据放入数据库
2.优点：数据持久化，可在任何时间任何地点访问
3.缺点：频繁读写数据库，造成数据库压力
购物车存储形式 - Redis
1.用户登录后，购物车数据存入Redis缓存
2.优点：数据持久化，可在任何地点任何时间访问；频繁读写只基于缓存，不会造成数据库压力；适用于集群与分布式系统，可扩展性强

订单状态流转
订单结算---->前往支付---->支付成功---->待发货
                |          |        /
                |          |     待收货
                v          v
            取消订单     订单完成
                |          |
                |          |
                v          v
            交易关闭     交易完成

复杂订单状态设计
待付款---->付款中---->付款成功---->已发货
            |           |          |
            v           v          v
         取消订单  取消订单,待退款 确认收货
            |           |
            v           v
         订单关闭      已退款


nginx的进程模型
1.master进程
2.worker进程

worker抢占机制

同步阻塞-BIO

Web请求事件处理机制
传统服务器事件处理：发生阻塞创建新的worker进程
nginx事件处理：发生阻塞跳过当前请求处理下一个请求 （use epoll；linux的epoll模型）

nginx.conf配置结构
main：全局配置
event：配置工作模式以及连接数
http：http模块相关配置 {
    server：虚拟主机配置，可以有多个 {
        location：路由规则，表达式
        upstream：集群，内网服务器
    }
}

1. 同步阻塞： 客户端发送请求给服务端，此时服务端处理任务时间很久，则客户端则被服务端堵塞了，
所以客户端会一直等待服务端的响应，此时客户端不能做其他任何事，服务端也不会接受其他客户端的
请求。这种通信机制比较简单粗暴，但是效率不高。

BIO： 我去上厕所，这个时候坑位都满了，我必须等待坑位释放了，我才能上吧？！此时我啥都不干，站在厕所里盯着，过了一会有人出来了，我就赶紧蹲上去。

2. 同步非阻塞： 客户端发送请求给服务端，此时服务端处理任务时间很久，这个时候虽然客户端会一
直等待响应，但是服务端可以处理其他的请求，过一会回来处理原先的。这种方式很高效，一个服务端
可以处理很多请求，不会在因为任务没有处理完而堵着，所以这是非阻塞的。

NIO： 我去上厕所，这个时候坑位都满了，没关系，哥不急，我出去抽根烟，过会回来看看有没有空位，如果有我就蹲，如果没有我出去接着抽烟或者玩会手机。

3. 异步阻塞： 客户端发送请求给服务端，此时服务端处理任务时间很久，但是客户端不会等待服务器
响应，它可以做其他的任务，等服务器处理完毕后再把结果响应给客户端，客户端得到回调后再处理服
务端的响应。这种方式可以避免客户端一直处于等待的状态，优化了用户体验，其实就是类似于网页里
发起的ajax异步请求。

异步阻塞： 我去上厕所，这个时候坑位都满了，没事我等着，等有了新的空位，让他通知我就行，通知了我，我就蹲上去。

4. 异步非阻塞： 客户端发送请求给服务端，此时服务端处理任务时间很久，这个时候的任务虽然处理
时间会很久，但是客户端可以做其他的任务，因为他是异步的，可以在回调函数里处理响应；同时服务
端是非阻塞的，所以服务端可以去处理其他的任务，如此，这个模式就显得非常的高效了。

AIO： 我去上厕所，这个时候坑位都满了，没事，我一点也不急，我去厕所外面抽根烟再玩玩手机，等有新的坑位释放了，会有人通知我的，通知我了，我就可以进去蹲了。